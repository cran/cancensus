<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Data discovery</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<style type="text/css">.pagedtable {
overflow: auto;
padding-left: 8px;
padding-right: 8px;
}
.pagedtable-wrapper {
border: 1px solid #ccc;
border-radius: 4px;
margin-bottom: 10px;
}
.pagedtable table {
width: 100%;
max-width: 100%;
margin: 0;
}
.pagedtable th {
padding: 0 5px 0 5px;
border: none;
border-bottom: 2px solid #dddddd;
min-width: 45px;
}
.pagedtable-empty th {
display: none;
}
.pagedtable td {
padding: 0 4px 0 4px;
}
.pagedtable .even {
background-color: rgba(140, 140, 140, 0.1);
}
.pagedtable-padding-col {
display: none;
}
.pagedtable a {
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
}
.pagedtable-index-nav {
cursor: pointer;
padding: 0 5px 0 5px;
float: right;
border: 0;
}
.pagedtable-index-nav-disabled {
cursor: default;
text-decoration: none;
color: #999;
}
a.pagedtable-index-nav-disabled:hover {
text-decoration: none;
color: #999;
}
.pagedtable-indexes {
cursor: pointer;
float: right;
border: 0;
}
.pagedtable-index-current {
cursor: default;
text-decoration: none;
font-weight: bold;
color: #333;
border: 0;
}
a.pagedtable-index-current:hover {
text-decoration: none;
font-weight: bold;
color: #333;
}
.pagedtable-index {
width: 30px;
display: inline-block;
text-align: center;
border: 0;
}
.pagedtable-index-separator-left {
display: inline-block;
color: #333;
font-size: 9px;
padding: 0 0 0 0;
cursor: default;
}
.pagedtable-index-separator-right {
display: inline-block;
color: #333;
font-size: 9px;
padding: 0 4px 0 0;
cursor: default;
}
.pagedtable-footer {
padding-top: 4px;
padding-bottom: 5px;
}
.pagedtable-not-empty .pagedtable-footer {
border-top: 2px solid #dddddd;
}
.pagedtable-info {
overflow: hidden;
color: #999;
white-space: nowrap;
text-overflow: ellipsis;
}
.pagedtable-header-name {
overflow: hidden;
text-overflow: ellipsis;
}
.pagedtable-header-type {
color: #999;
font-weight: 400;
}
.pagedtable-na-cell {
font-style: italic;
opacity: 0.3;
}
</style>
<script>// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this === null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback, thisArg) {

    var T, A, k;

    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this|
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let A be a new array created as if by the expression new Array(len)
    //    where Array is the standard built-in constructor with that name and
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal
        //     method of callback with T as the this value and argument
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}

var PagedTable = function (pagedTable) {
  var me = this;

  var source = function(pagedTable) {
    var sourceElems = [].slice.call(pagedTable.children).filter(function(e) {
      return e.hasAttribute("data-pagedtable-source");
    });

    if (sourceElems === null || sourceElems.length !== 1) {
      throw("A single data-pagedtable-source was not found");
    }

    return JSON.parse(sourceElems[0].innerHTML);
  }(pagedTable);

  var options = function(source) {
    var options = typeof(source.options) !== "undefined" &&
      source.options !== null ? source.options : {};

    var columns = typeof(options.columns) !== "undefined" ? options.columns : {};
    var rows = typeof(options.rows) !== "undefined" ? options.rows : {};

    var positiveIntOrNull = function(value) {
      return parseInt(value) >= 0 ? parseInt(value) : null;
    };

    return {
      pages: positiveIntOrNull(options.pages),
      rows: {
        min: positiveIntOrNull(rows.min),
        max: positiveIntOrNull(rows.max),
        total: positiveIntOrNull(rows.total)
      },
      columns: {
        min: positiveIntOrNull(columns.min),
        max: positiveIntOrNull(columns.max),
        total: positiveIntOrNull(columns.total)
      }
    };
  }(source);

  var Measurer = function() {

    // set some default initial values that will get adjusted in runtime
    me.measures = {
      padding: 12,
      character: 8,
      height: 15,
      defaults: true
    };

    me.calculate = function(measuresCell) {
      if (!me.measures.defaults)
        return;

      var measuresCellStyle = window.getComputedStyle(measuresCell, null);

      var newPadding = parsePadding(measuresCellStyle.paddingLeft) +
            parsePadding(measuresCellStyle.paddingRight);

      var sampleString = "ABCDEFGHIJ0123456789";
      var newCharacter = Math.ceil(measuresCell.clientWidth / sampleString.length);

      if (newPadding <= 0 || newCharacter <= 0)
        return;

      me.measures.padding = newPadding;
      me.measures.character = newCharacter;
      me.measures.height = measuresCell.clientHeight;
      me.measures.defaults = false;
    };

    return me;
  };

  var Page = function(data, options) {
    var me = this;

    var defaults = {
      max: 7,
      rows: 10
    };

    var totalPages = function() {
      return Math.ceil(data.length / me.rows);
    };

    me.number = 0;
    me.max = options.pages !== null ? options.pages : defaults.max;
    me.visible = me.max;
    me.rows = options.rows.min !== null ? options.rows.min : defaults.rows;
    me.total = totalPages();

    me.setRows = function(newRows) {
      me.rows = newRows;
      me.total = totalPages();
    };

    me.setPageNumber = function(newPageNumber) {
      if (newPageNumber < 0) newPageNumber = 0;
      if (newPageNumber >= me.total) newPageNumber = me.total - 1;

      me.number = newPageNumber;
    };

    me.setVisiblePages = function(visiblePages) {
      me.visible = Math.min(me.max, visiblePages);
      me.setPageNumber(me.number);
    };

    me.getVisiblePageRange = function() {
      var start = me.number - Math.max(Math.floor((me.visible - 1) / 2), 0);
      var end = me.number + Math.floor(me.visible / 2) + 1;
      var pageCount = me.total;

      if (start < 0) {
        var diffToStart = 0 - start;
        start += diffToStart;
        end += diffToStart;
      }

      if (end > pageCount) {
        var diffToEnd = end - pageCount;
        start -= diffToEnd;
        end -= diffToEnd;
      }

      start = start < 0 ? 0 : start;
      end = end >= pageCount ? pageCount : end;

      var first = false;
      var last = false;

      if (start > 0 && me.visible > 1) {
        start = start + 1;
        first = true;
      }

      if (end < pageCount && me.visible > 2) {
        end = end - 1;
        last = true;
      }

      return {
        first: first,
        start: start,
        end: end,
        last: last
      };
    };

    me.getRowStart = function() {
      var rowStart = page.number * page.rows;
      if (rowStart < 0)
        rowStart = 0;

      return rowStart;
    };

    me.getRowEnd = function() {
      var rowStart = me.getRowStart();
      return Math.min(rowStart + me.rows, data.length);
    };

    me.getPaddingRows = function() {
      var rowStart = me.getRowStart();
      var rowEnd = me.getRowEnd();
      return data.length > me.rows ? me.rows - (rowEnd - rowStart) : 0;
    };
  };

  var Columns = function(data, columns, options) {
    var me = this;

    me.defaults = {
      min: 5
    };

    me.number = 0;
    me.visible = 0;
    me.total = columns.length;
    me.subset = [];
    me.padding = 0;
    me.min = options.columns.min !== null ? options.columns.min : me.defaults.min;
    me.max = options.columns.max !== null ? options.columns.max : null;
    me.widths = {};

    var widthsLookAhead = Math.max(100, options.rows.min);
    var paddingColChars = 10;

    me.emptyNames = function() {
      columns.forEach(function(column) {
        if (columns.label !== null && columns.label !== "")
          return false;
      });

      return true;
    };

    var parsePadding = function(value) {
      return parseInt(value) >= 0 ? parseInt(value) : 0;
    };

    me.calculateWidths = function(measures) {
      columns.forEach(function(column) {
        var maxChars = Math.max(
          column.label.toString().length,
          column.type.toString().length
        );

        for (var idxRow = 0; idxRow < Math.min(widthsLookAhead, data.length); idxRow++) {
          maxChars = Math.max(maxChars, data[idxRow][column.name.toString()].length);
        }

        me.widths[column.name] = {
          // width in characters
          chars: maxChars,
          // width for the inner html columns
          inner: maxChars * measures.character,
          // width adding outer styles like padding
          outer: maxChars * measures.character + measures.padding
        };
      });
    };

    me.getWidth = function() {
      var widthOuter = 0;
      for (var idxCol = 0; idxCol < me.subset.length; idxCol++) {
        var columnName = me.subset[idxCol].name;
        widthOuter = widthOuter + me.widths[columnName].outer;
      }

      widthOuter = widthOuter + me.padding * paddingColChars * measurer.measures.character;

      if (me.hasMoreLeftColumns()) {
        widthOuter = widthOuter + columnNavigationWidthPX + measurer.measures.padding;
      }

      if (me.hasMoreRightColumns()) {
        widthOuter = widthOuter + columnNavigationWidthPX + measurer.measures.padding;
      }

      return widthOuter;
    };

    me.updateSlice = function() {
      if (me.number + me.visible >= me.total)
        me.number = me.total - me.visible;

      if (me.number < 0) me.number = 0;

      me.subset = columns.slice(me.number, Math.min(me.number + me.visible, me.total));

      me.subset = me.subset.map(function(column) {
        Object.keys(column).forEach(function(colKey) {
          column[colKey] = column[colKey] === null ? "" : column[colKey].toString();
        });

        column.width = null;
        return column;
      });
    };

    me.setVisibleColumns = function(columnNumber, newVisibleColumns, paddingCount) {
      me.number = columnNumber;
      me.visible = newVisibleColumns;
      me.padding = paddingCount;

      me.updateSlice();
    };

    me.incColumnNumber = function(increment) {
      me.number = me.number + increment;
    };

    me.setColumnNumber = function(newNumber) {
      me.number = newNumber;
    };

    me.setPaddingCount = function(newPadding) {
      me.padding = newPadding;
    };

    me.getPaddingCount = function() {
      return me.padding;
    };

    me.hasMoreLeftColumns = function() {
      return me.number > 0;
    };

    me.hasMoreRightColumns = function() {
      return me.number + me.visible < me.total;
    };

    me.updateSlice(0);
    return me;
  };

  var data = source.data;
  var page = new Page(data, options);
  var measurer = new Measurer(data, options);
  var columns = new Columns(data, source.columns, options);

  var table = null;
  var tableDiv = null;
  var header = null;
  var footer = null;
  var tbody = null;

  // Caches pagedTable.clientWidth, specially for webkit
  var cachedPagedTableClientWidth = null;

  var onChangeCallbacks = [];

  var clearSelection = function() {
    if(document.selection && document.selection.empty) {
      document.selection.empty();
    } else if(window.getSelection) {
      var sel = window.getSelection();
      sel.removeAllRanges();
    }
  };

  var columnNavigationWidthPX = 5;

  var renderColumnNavigation = function(increment, backwards) {
    var arrow = document.createElement("div");
    arrow.setAttribute("style",
      "border-top: " + columnNavigationWidthPX + "px solid transparent;" +
      "border-bottom: " + columnNavigationWidthPX + "px solid transparent;" +
      "border-" + (backwards ? "right" : "left") + ": " + columnNavigationWidthPX + "px solid;");

    var header = document.createElement("th");
    header.appendChild(arrow);
    header.setAttribute("style",
      "cursor: pointer;" +
      "vertical-align: middle;" +
      "min-width: " + columnNavigationWidthPX + "px;" +
      "width: " + columnNavigationWidthPX + "px;");

    header.onclick = function() {
      columns.incColumnNumber(backwards ? -1 : increment);

      me.animateColumns(backwards);
      renderFooter();

      clearSelection();
      triggerOnChange();
    };

    return header;
  };

  var maxColumnWidth = function(width) {
    var padding = 80;
    var columnMax = Math.max(cachedPagedTableClientWidth - padding, 0);

    return parseInt(width) > 0 ?
      Math.min(columnMax, parseInt(width)) + "px" :
      columnMax + "px";
  };

  var clearHeader = function() {
    var thead = pagedTable.querySelectorAll("thead")[0];
    thead.innerHTML = "";
  };

  var renderHeader = function(clear) {
    cachedPagedTableClientWidth = pagedTable.clientWidth;

    var fragment = document.createDocumentFragment();

    header = document.createElement("tr");
    fragment.appendChild(header);

    if (columns.number > 0)
      header.appendChild(renderColumnNavigation(-columns.visible, true));

    columns.subset = columns.subset.map(function(columnData) {
      var column = document.createElement("th");
      column.setAttribute("align", columnData.align);
      column.style.textAlign = columnData.align;

      column.style.maxWidth = maxColumnWidth(null);
      if (columnData.width) {
        column.style.minWidth =
          column.style.maxWidth = maxColumnWidth(columnData.width);
      }

      var columnName = document.createElement("div");
      columnName.setAttribute("class", "pagedtable-header-name");
      if (columnData.label === "") {
        columnName.innerHTML = "&nbsp;";
      }
      else {
        columnName.appendChild(document.createTextNode(columnData.label));
      }
      column.appendChild(columnName);

      var columnType = document.createElement("div");
      columnType.setAttribute("class", "pagedtable-header-type");
      if (columnData.type === "") {
        columnType.innerHTML = "&nbsp;";
      }
      else {
        columnType.appendChild(document.createTextNode("<" + columnData.type + ">"));
      }
      column.appendChild(columnType);

      header.appendChild(column);

      columnData.element = column;

      return columnData;
    });

    for (var idx = 0; idx < columns.getPaddingCount(); idx++) {
      var paddingCol = document.createElement("th");
      paddingCol.setAttribute("class", "pagedtable-padding-col");
      header.appendChild(paddingCol);
    }

    if (columns.number + columns.visible < columns.total)
      header.appendChild(renderColumnNavigation(columns.visible, false));

    if (typeof(clear) == "undefined" || clear) clearHeader();
    var thead = pagedTable.querySelectorAll("thead")[0];
    thead.appendChild(fragment);
  };

  me.animateColumns = function(backwards) {
    var thead = pagedTable.querySelectorAll("thead")[0];

    var headerOld = thead.querySelectorAll("tr")[0];
    var tbodyOld = table.querySelectorAll("tbody")[0];

    me.fitColumns(backwards);

    renderHeader(false);

    header.style.opacity = "0";
    header.style.transform = backwards ? "translateX(-30px)" : "translateX(30px)";
    header.style.transition = "transform 200ms linear, opacity 200ms";
    header.style.transitionDelay = "0";

    renderBody(false);

    if (headerOld) {
      headerOld.style.position = "absolute";
      headerOld.style.transform = "translateX(0px)";
      headerOld.style.opacity = "1";
      headerOld.style.transition = "transform 100ms linear, opacity 100ms";
      headerOld.setAttribute("class", "pagedtable-remove-head");
      if (headerOld.style.transitionEnd) {
        headerOld.addEventListener("transitionend", function() {
          var headerOldByClass = thead.querySelector(".pagedtable-remove-head");
          if (headerOldByClass) thead.removeChild(headerOldByClass);
        });
      }
      else {
        thead.removeChild(headerOld);
      }
    }

    if (tbodyOld) table.removeChild(tbodyOld);

    tbody.style.opacity = "0";
    tbody.style.transition = "transform 200ms linear, opacity 200ms";
    tbody.style.transitionDelay = "0ms";

    // force relayout
    window.getComputedStyle(header).opacity;
    window.getComputedStyle(tbody).opacity;

    if (headerOld) {
      headerOld.style.transform = backwards ? "translateX(20px)" : "translateX(-30px)";
      headerOld.style.opacity = "0";
    }

    header.style.transform = "translateX(0px)";
    header.style.opacity = "1";

    tbody.style.opacity = "1";
  }

  me.onChange = function(callback) {
    onChangeCallbacks.push(callback);
  };

  var triggerOnChange = function() {
    onChangeCallbacks.forEach(function(onChange) {
      onChange();
    });
  };

  var clearBody = function() {
    if (tbody) {
      table.removeChild(tbody);
      tbody = null;
    }
  };

  var renderBody = function(clear) {
    cachedPagedTableClientWidth = pagedTable.clientWidth

    var fragment = document.createDocumentFragment();

    var pageData = data.slice(page.getRowStart(), page.getRowEnd());

    pageData.forEach(function(dataRow, idxRow) {
      var htmlRow = document.createElement("tr");
      htmlRow.setAttribute("class", (idxRow % 2 !==0) ? "even" : "odd");

      if (columns.hasMoreLeftColumns())
        htmlRow.appendChild(document.createElement("td"));

      columns.subset.forEach(function(columnData) {
        var cellName = columnData.name;
        var dataCell = dataRow[cellName];
        var htmlCell = document.createElement("td");

        if (dataCell === "NA") htmlCell.setAttribute("class", "pagedtable-na-cell");
        if (dataCell === "__NA__") dataCell = "NA";

        var cellText = document.createTextNode(dataCell);
        htmlCell.appendChild(cellText);
        if (dataCell.length > 50) {
          htmlCell.setAttribute("title", dataCell);
        }
        htmlCell.setAttribute("align", columnData.align);
        htmlCell.style.textAlign = columnData.align;
        htmlCell.style.maxWidth = maxColumnWidth(null);
        if (columnData.width) {
          htmlCell.style.minWidth = htmlCell.style.maxWidth = maxColumnWidth(columnData.width);
        }
        htmlRow.appendChild(htmlCell);
      });

      for (var idx = 0; idx < columns.getPaddingCount(); idx++) {
        var paddingCol = document.createElement("td");
        paddingCol.setAttribute("class", "pagedtable-padding-col");
        htmlRow.appendChild(paddingCol);
      }

      if (columns.hasMoreRightColumns())
        htmlRow.appendChild(document.createElement("td"));

      fragment.appendChild(htmlRow);
    });

    for (var idxPadding = 0; idxPadding < page.getPaddingRows(); idxPadding++) {
      var paddingRow = document.createElement("tr");

      var paddingCellRow = document.createElement("td");
      paddingCellRow.innerHTML = "&nbsp;";
      paddingCellRow.setAttribute("colspan", "100%");
      paddingRow.appendChild(paddingCellRow);

      fragment.appendChild(paddingRow);
    }

    if (typeof(clear) == "undefined" || clear) clearBody();
    tbody = document.createElement("tbody");
    tbody.appendChild(fragment);

    table.appendChild(tbody);
  };

  var getLabelInfo = function() {
    var pageStart = page.getRowStart();
    var pageEnd = page.getRowEnd();
    var totalRows = data.length;

    var totalRowsLabel = options.rows.total ? options.rows.total : totalRows;
    var totalRowsLabelFormat = totalRowsLabel.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');

    var infoText = (pageStart + 1) + "-" + pageEnd + " of " + totalRowsLabelFormat + " rows";
    if (totalRows < page.rows) {
      infoText = totalRowsLabel + " row" + (totalRows != 1 ? "s" : "");
    }
    if (columns.total > columns.visible) {
      var totalColumnsLabel = options.columns.total ? options.columns.total : columns.total;

      infoText = infoText + " | " + (columns.number + 1) + "-" +
        (Math.min(columns.number + columns.visible, columns.total)) +
        " of " + totalColumnsLabel + " columns";
    }

    return infoText;
  };

  var clearFooter = function() {
    footer = pagedTable.querySelectorAll("div.pagedtable-footer")[0];
    footer.innerHTML = "";

    return footer;
  };

  var createPageLink = function(idxPage) {
    var pageLink = document.createElement("a");
    pageLinkClass = idxPage === page.number ? "pagedtable-index pagedtable-index-current" : "pagedtable-index";
    pageLink.setAttribute("class", pageLinkClass);
    pageLink.setAttribute("data-page-index", idxPage);
    pageLink.onclick = function() {
      page.setPageNumber(parseInt(this.getAttribute("data-page-index")));
      renderBody();
      renderFooter();

      triggerOnChange();
    };

    pageLink.appendChild(document.createTextNode(idxPage + 1));

    return pageLink;
  }

  var renderFooter = function() {
    footer = clearFooter();

    var next = document.createElement("a");
    next.appendChild(document.createTextNode("Next"));
    next.onclick = function() {
      page.setPageNumber(page.number + 1);
      renderBody();
      renderFooter();

      triggerOnChange();
    };
    if (data.length > page.rows) footer.appendChild(next);

    var pageNumbers = document.createElement("div");
    pageNumbers.setAttribute("class", "pagedtable-indexes");

    var pageRange = page.getVisiblePageRange();

    if (pageRange.first) {
      var pageLink = createPageLink(0);
      pageNumbers.appendChild(pageLink);

      var pageSeparator = document.createElement("div");
      pageSeparator.setAttribute("class", "pagedtable-index-separator-left");
      pageSeparator.appendChild(document.createTextNode("..."))
      pageNumbers.appendChild(pageSeparator);
    }

    for (var idxPage = pageRange.start; idxPage < pageRange.end; idxPage++) {
      var pageLink = createPageLink(idxPage);

      pageNumbers.appendChild(pageLink);
    }

    if (pageRange.last) {
      var pageSeparator = document.createElement("div");
      pageSeparator.setAttribute("class", "pagedtable-index-separator-right");
      pageSeparator.appendChild(document.createTextNode("..."))
      pageNumbers.appendChild(pageSeparator);

      var pageLink = createPageLink(page.total - 1);
      pageNumbers.appendChild(pageLink);
    }

    if (data.length > page.rows) footer.appendChild(pageNumbers);

    var previous = document.createElement("a");
    previous.appendChild(document.createTextNode("Previous"));
    previous.onclick = function() {
      page.setPageNumber(page.number - 1);
      renderBody();
      renderFooter();

      triggerOnChange();
    };
    if (data.length > page.rows) footer.appendChild(previous);

    var infoLabel = document.createElement("div");
    infoLabel.setAttribute("class", "pagedtable-info");
    infoLabel.setAttribute("title", getLabelInfo());
    infoLabel.appendChild(document.createTextNode(getLabelInfo()));
    footer.appendChild(infoLabel);

    var enabledClass = "pagedtable-index-nav";
    var disabledClass = "pagedtable-index-nav pagedtable-index-nav-disabled";
    previous.setAttribute("class", page.number <= 0 ? disabledClass : enabledClass);
    next.setAttribute("class", (page.number + 1) * page.rows >= data.length ? disabledClass : enabledClass);
  };

  var measuresCell = null;

  var renderMeasures = function() {
    var measuresTable = document.createElement("table");
    measuresTable.style.visibility = "hidden";
    measuresTable.style.position = "absolute";
    measuresTable.style.whiteSpace = "nowrap";
    measuresTable.style.height = "auto";
    measuresTable.style.width = "auto";

    var measuresRow = document.createElement("tr");
    measuresTable.appendChild(measuresRow);

    measuresCell = document.createElement("td");
    var sampleString = "ABCDEFGHIJ0123456789";
    measuresCell.appendChild(document.createTextNode(sampleString));

    measuresRow.appendChild(measuresCell);

    tableDiv.appendChild(measuresTable);
  }

  me.init = function() {
    tableDiv = document.createElement("div");
    pagedTable.appendChild(tableDiv);
    var pagedTableClass = data.length > 0 ?
      "pagedtable pagedtable-not-empty" :
      "pagedtable pagedtable-empty";

    if (columns.total == 0 || (columns.emptyNames() && data.length == 0)) {
      pagedTableClass = pagedTableClass + " pagedtable-empty-columns";
    }

    tableDiv.setAttribute("class", pagedTableClass);

    renderMeasures();
    measurer.calculate(measuresCell);
    columns.calculateWidths(measurer.measures);

    table = document.createElement("table");
    table.setAttribute("cellspacing", "0");
    table.setAttribute("class", "table table-condensed");
    tableDiv.appendChild(table);

    table.appendChild(document.createElement("thead"));

    var footerDiv = document.createElement("div");
    footerDiv.setAttribute("class", "pagedtable-footer");
    tableDiv.appendChild(footerDiv);

    // if the host has not yet provided horizontal space, render hidden
    if (tableDiv.clientWidth <= 0) {
      tableDiv.style.opacity = "0";
    }

    me.render();

    // retry seizing columns later if the host has not provided space
    function retryFit() {
      if (tableDiv.clientWidth <= 0) {
        setTimeout(retryFit, 100);
      } else {
        me.render();
        triggerOnChange();
      }
    }
    if (tableDiv.clientWidth <= 0) {
      retryFit();
    }
  };

  var registerWidths = function() {
    columns.subset = columns.subset.map(function(column) {
      column.width = columns.widths[column.name].inner;
      return column;
    });
  };

  var parsePadding = function(value) {
    return parseInt(value) >= 0 ? parseInt(value) : 0;
  };

  me.fixedHeight = function() {
    return options.rows.max != null;
  }

  me.fitRows = function() {
    if (me.fixedHeight())
      return;

    measurer.calculate(measuresCell);

    var rows = options.rows.min !== null ? options.rows.min : 0;
    var headerHeight = header !== null && header.offsetHeight > 0 ? header.offsetHeight : 0;
    var footerHeight = footer !== null && footer.offsetHeight > 0 ? footer.offsetHeight : 0;

    if (pagedTable.offsetHeight > 0) {
      var availableHeight = pagedTable.offsetHeight - headerHeight - footerHeight;
      rows = Math.floor((availableHeight) / measurer.measures.height);
    }

    rows = options.rows.min !== null ? Math.max(options.rows.min, rows) : rows;

    page.setRows(rows);
  }

  // The goal of this function is to add as many columns as possible
  // starting from left-to-right, when the right most limit is reached
  // it tries to add columns from the left as well.
  //
  // When startBackwards is true columns are added from right-to-left
  me.fitColumns = function(startBackwards) {
    measurer.calculate(measuresCell);
    columns.calculateWidths(measurer.measures);

    if (tableDiv.clientWidth > 0) {
      tableDiv.style.opacity = 1;
    }

    var visibleColumns = tableDiv.clientWidth <= 0 ? Math.max(columns.min, 1) : 1;
    var columnNumber = columns.number;
    var paddingCount = 0;

    // track a list of added columns as we build the visible ones to allow us
    // to remove columns when they don't fit anymore.
    var columnHistory = [];

    var lastTableHeight = 0;
    var backwards = startBackwards;

    var tableDivStyle = window.getComputedStyle(tableDiv, null);
    var tableDivPadding = parsePadding(tableDivStyle.paddingLeft) +
      parsePadding(tableDivStyle.paddingRight);

    var addPaddingCol = false;
    var currentWidth = 0;

    while (true) {
      columns.setVisibleColumns(columnNumber, visibleColumns, paddingCount);
      currentWidth = columns.getWidth();

      if (tableDiv.clientWidth - tableDivPadding < currentWidth) {
        break;
      }

      columnHistory.push({
        columnNumber: columnNumber,
        visibleColumns: visibleColumns,
        paddingCount: paddingCount
      });

      if (columnHistory.length > 100) {
        console.error("More than 100 tries to fit columns, aborting");
        break;
      }

      if (columns.max !== null &&
        columns.visible + columns.getPaddingCount() >= columns.max) {
        break;
      }

      // if we run out of right-columns
      if (!backwards && columnNumber + columns.visible >= columns.total) {
        // if we started adding right-columns, try adding left-columns
        if (!startBackwards && columnNumber > 0) {
          backwards = true;
        }
        else if (columns.min === null || visibleColumns + columns.getPaddingCount() >= columns.min) {
          break;
        }
        else {
          paddingCount = paddingCount + 1;
        }
      }

      // if we run out of left-columns
      if (backwards && columnNumber == 0) {
        // if we started adding left-columns, try adding right-columns
        if (startBackwards && columnNumber + columns.visible < columns.total) {
          backwards = false;
        }
        else if (columns.min === null || visibleColumns + columns.getPaddingCount() >= columns.min) {
          break;
        }
        else {
          paddingCount = paddingCount + 1;
        }
      }

      // when moving backwards try fitting left columns first
      if (backwards && columnNumber > 0) {
        columnNumber = columnNumber - 1;
      }

      if (columnNumber + visibleColumns < columns.total) {
        visibleColumns = visibleColumns + 1;
      }
    }

    var lastRenderableColumn = {
        columnNumber: columnNumber,
        visibleColumns: visibleColumns,
        paddingCount: paddingCount
    };

    if (columnHistory.length > 0) {
      lastRenderableColumn = columnHistory[columnHistory.length - 1];
    }

    columns.setVisibleColumns(
      lastRenderableColumn.columnNumber,
      lastRenderableColumn.visibleColumns,
      lastRenderableColumn.paddingCount);

    if (pagedTable.offsetWidth > 0) {
      page.setVisiblePages(Math.max(Math.ceil(1.0 * (pagedTable.offsetWidth - 250) / 40), 2));
    }

    registerWidths();
  };

  me.fit = function(startBackwards) {
    me.fitRows();
    me.fitColumns(startBackwards);
  }

  me.render = function() {
    me.fitColumns(false);

    // render header/footer to measure height accurately
    renderHeader();
    renderFooter();

    me.fitRows();
    renderBody();

    // re-render footer to match new rows
    renderFooter();
  }

  var resizeLastWidth = -1;
  var resizeLastHeight = -1;
  var resizeNewWidth = -1;
  var resizeNewHeight = -1;
  var resizePending = false;

  me.resize = function(newWidth, newHeight) {

    function resizeDelayed() {
      resizePending = false;

      if (
        (resizeNewWidth !== resizeLastWidth) ||
        (!me.fixedHeight() && resizeNewHeight !== resizeLastHeight)
      ) {
        resizeLastWidth = resizeNewWidth;
        resizeLastHeight = resizeNewHeight;

        setTimeout(resizeDelayed, 200);
        resizePending = true;
      } else {
        me.render();
        triggerOnChange();

        resizeLastWidth = -1;
        resizeLastHeight = -1;
      }
    }

    resizeNewWidth = newWidth;
    resizeNewHeight = newHeight;

    if (!resizePending) resizeDelayed();
  };
};

var PagedTableDoc;
(function (PagedTableDoc) {
  var allPagedTables = [];

  PagedTableDoc.initAll = function() {
    allPagedTables = [];

    var pagedTables = [].slice.call(document.querySelectorAll('[data-pagedtable="false"],[data-pagedtable=""]'));
    pagedTables.forEach(function(pagedTable, idx) {
      pagedTable.setAttribute("data-pagedtable", "true");
      pagedTable.setAttribute("pagedtable-page", 0);
      pagedTable.setAttribute("class", "pagedtable-wrapper");

      var pagedTableInstance = new PagedTable(pagedTable);
      pagedTableInstance.init();

      allPagedTables.push(pagedTableInstance);
    });
  };

  PagedTableDoc.resizeAll = function() {
    allPagedTables.forEach(function(pagedTable) {
      pagedTable.render();
    });
  };

  window.addEventListener("resize", PagedTableDoc.resizeAll);

  return PagedTableDoc;
})(PagedTableDoc || (PagedTableDoc = {}));

window.onload = function() {
  PagedTableDoc.initAll();
};
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Data discovery</h1>
<h3 class="subtitle">Resources for finding available and relevant
data</h3>



<div id="census-datasets" class="section level1">
<h1>Census datasets</h1>
<p><code>cancensus</code> can access Statistics Canada Census data for
the 1996, 2001, 2006 Censuses, the 2011 Census and National Household
Survey, the 2016 Census, as well as the 2021 Census. You can run
<code>list_census_datasets</code> to check what datasets are currently
available for access through the CensusMapper API.</p>
<p>Thanks to contributions by the Canada Mortgage and Housing
Corporation (CMHC), <code>cancensus</code> now includes additional
Census-linked datasets as open-data releases. These include annual
tax-filer data at the census tract level for tax years 2000 through
2017, which includes data on incomes and demographics, as well as
specialized crosstabs for Structural type of dwelling by Document type,
which details occupancy status for residences. These crosstabs are
available for the 2001, 2006, 2011, and 2016 Census years at all levels
starting with census tract.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">list_census_datasets</span>()</span></code></pre></div>
<pre><code>## # A tibble: 29 × 6
##    dataset description                           geo_d…¹ attri…² refer…³ refer…⁴
##    &lt;chr&gt;   &lt;chr&gt;                                 &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  
##  1 CA1996  1996 Canada Census                    CA1996  StatCa… 92-351… https:…
##  2 CA01    2001 Canada Census                    CA01    StatCa… 92-378… https:…
##  3 CA06    2006 Canada Census                    CA06    StatCa… 92-566… https:…
##  4 CA11    2011 Canada Census and NHS            CA11    StatCa… 98-301… https:…
##  5 CA16    2016 Canada Census                    CA16    StatCa… 98-301… https:…
##  6 CA21    2021 Canada Census                    CA21    StatCa… 98-301… https:…
##  7 CA01xSD 2001 Canada Census xtab - Structural… CA01    StatCa… 92-378… https:…
##  8 CA06xSD 2006 Canada Census xtab - Structural… CA06    StatCa… 92-566… https:…
##  9 CA11xSD 2011 Canada Census xtab - Structural… CA11    StatCa… 98-301… https:…
## 10 CA16xSD 2016 Canada Census xtab - Structural… CA16    StatCa… 98-301… https:…
## # … with 19 more rows, and abbreviated variable names ¹​geo_dataset,
## #   ²​attribution, ³​reference, ⁴​reference_url</code></pre>
<p>The <code>list_census_datasets()</code> function also provides
additional background like series reference code, catalogue reference,
and attribution details.</p>
</div>
<div id="variable-vectors" class="section level1">
<h1>Variable vectors</h1>
<p><img src="data:image/png;base64,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mbzXKmg54Slg7ty56rjtwAMPFKyZ84bff/9dPv30UznkkEO80XG3t23bJl988YXMmDFD61O9evWIuuPEBQsWyLfffiuHHnponnzgvxts4EYFDGxAOcFm5cqVUqtWrTzltOmif9etW6f5ff7551KhQgWpWLFidBLZnzZEJqlmk+ia4An3w7g3cF/5CQVls3jxYvnqq68E902JEiUiLpksm4iTPTtZqQHhob7//vvlH//4h0BYfPnll9KxY0d9ED1s9KEdMWKEDB061Bvtbr/66qsycODACJ9EcI7WvXt310f11KlTNT08N3bq1Ek+/PBDeeGFF6Rfv34qbHAQN1avXr1kxYoVMmzYMPd6BS3n9u3bpXPnziosxo4dq4t2vf7nduzYIXj/vPHGG26dEm2sXbtW/W+/9tprgrK99NJLWicIJW94+OGHtQ4Qqt4Qz383zocTuf/+978qhK+44ooIFyvePLzbECxgjYcE7Xj33XcLru0N4J5sG+L8VLNJdM0nnnhCHnnkEb0/4HIYwja/UFA2vXv3lieffFI/9IB76JNPPnEvmSwb98RYG/CImG1h1KhRzvXXX+8YzcatuhEMzsUXX+wYuG6caQDn6aefdi655BLnhx9+cON3797t3HXXXY7xvuj89a9/jTjHCDLHaACa1rztnbPOOkuP45qPP/64m8cNN9zgvP/++7qPfD766CPdxvXvvfdex2gETkHL+cwzzzhGoLnX9F7nxx9/dC677DKtwx133OGmSbSBur344osRSYwAc4yAduPMxwGcK6+80hk5cqSW3z1gNq666irHCHuNMsLMadeundYTeT744INu0jFjxjhGqLj7sTa+//57p3Xr1s6yZcvcw0azdNq3b+8YQefG7U8bFgWbeNc07oX1vtyyZYvWyQgf5/nnn3frF2ujoGy++eYbx7wE3Kxxn9566626H6+cbuIkN7JSA5ozZ45cc801EWr+aaedJubGd7th6CJMmTJFTj/9dGnVqpW8/vrrrvzGsZNOOkmMQHHjsLFp0yaB2mvdgUBdRhcMPqq//vpr13c10iKNaUx1qAZVt0GDBjJ9+nSBm1loVXCqX9ByIt8mTZrgchqwje4RArSOe+65RzU/jcjnH7pG8DhghFZEyjvvvFNuvPFGN+6tt96Sv/3tb8rszTff1O4rDiby342366mnnqpdMHRDr776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" /><!-- --></p>
<p>The Census datasets that the <code>cancensus</code> package provides
access to are rich in detail but they can be complex to navigate. There
are thousands of variable vectors, including separate vector indicators
for aggregations split by <code>Total</code>, <code>Female</code>, and
<code>Male</code> populations. As a result, the total number of vectors
per dataset is significant, ranging from 1,715 in the <code>CA01</code>
dataset to 6,623 in the <code>CA16</code> one.</p>
<div id="view-available-census-variable-vectors" class="section level2">
<h2>View available Census variable vectors</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">list_census_vectors</span>(<span class="st">&#39;CA21&#39;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 7,709 × 7
##    vector    type   label                          units paren…¹ aggre…² details
##    &lt;chr&gt;     &lt;fct&gt;  &lt;chr&gt;                          &lt;fct&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  
##  1 v_CA21_1  Total  Population, 2021               Numb… &lt;NA&gt;    Additi… CA 202…
##  2 v_CA21_2  Total  Population, 2016               Numb… &lt;NA&gt;    Additi… CA 202…
##  3 v_CA21_3  Total  Population percentage change,… Numb… &lt;NA&gt;    Averag… CA 202…
##  4 v_CA21_4  Total  Total private dwellings        Numb… &lt;NA&gt;    Additi… CA 202…
##  5 v_CA21_5  Total  Private dwellings occupied by… Numb… v_CA21… Additi… CA 202…
##  6 v_CA21_6  Total  Population density per square… Ratio &lt;NA&gt;    Averag… CA 202…
##  7 v_CA21_7  Total  Land area in square kilometres Numb… &lt;NA&gt;    Additi… CA 202…
##  8 v_CA21_8  Total  Total - Age                    Numb… &lt;NA&gt;    Additi… CA 202…
##  9 v_CA21_9  Male   Total - Age                    Numb… &lt;NA&gt;    Additi… CA 202…
## 10 v_CA21_10 Female Total - Age                    Numb… &lt;NA&gt;    Additi… CA 202…
## # … with 7,699 more rows, and abbreviated variable names ¹​parent_vector,
## #   ²​aggregation</code></pre>
<p><code>list_census_vectors(dataset)</code> retrieves an index of all
available vectors for a given dataset from the CensusMapper API or local
cache if recently called. Each Census variable has a vector code
assigned to it with naming pattern that goes
<code>v_{dataset}_{index}</code>. This is the code by which vectors are
identified through the CensusMapper API. In addition the vector code,
there is additional information showing population type, aggregation
type, label and details, as well as variable hierarchy. This function
can also be used to show the variables for additional datasets made
accessible through the CensusMapper API.</p>
</div>
<div id="searching-for-census-variable-vectors" class="section level2">
<h2>Searching for Census variable vectors</h2>
<p>Due to the large number of Census variables it can be hard to find
the right data. There is a function for searching through Census
variable metadata in a few different ways. There are three types of
searches possible using this function: exact search, which simply looks
for exact string matches for a given query against the vector dataset;
keyword search, which breaks vector metadata into unigram tokens and
then tries to find the vectors with the greatest number of unique
matches; and, semantic search which works better with search phrases and
has tolerance for inexact searches. Switching between search modes is
done using the <code>query_type</code> argument when calling
<code>find_census_vectors()</code> function.</p>
<p>Note that variable search is optimized for the Census variables in
the main Census datasets. While searches generally work for variables in
additional datasets such as cross-tabs and taxfiler data, they have not
been extensively tested against these datasets.</p>
<div id="exact-search" class="section level3">
<h3>Exact search</h3>
<p>Exact search uses exact string matching. It is best used when you
know exactly the term you are looking for, and is not robust to spelling
errors.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&quot;Oji-cree&quot;</span>, <span class="at">dataset =</span> <span class="st">&quot;CA16&quot;</span>, <span class="at">type =</span> <span class="st">&quot;total&quot;</span>, <span class="at">query_type =</span> <span class="st">&quot;exact&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 4 × 4
##   vector      type  label    details                                            
##   &lt;chr&gt;       &lt;fct&gt; &lt;chr&gt;    &lt;chr&gt;                                              
## 1 v_CA16_626  Total Oji-Cree Language; Total - Mother tongue for the total popu…
## 2 v_CA16_1433 Total Oji-Cree Language; Total - Language spoken most often at ho…
## 3 v_CA16_2676 Total Oji-Cree 25% Data; Total - Knowledge of languages for the p…
## 4 v_CA16_5930 Total Oji-Cree 25% Data; Work; Total - Language used most often a…</code></pre>
<p>This, on the other hand, will return a warning.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&quot;Ojib-cree&quot;</span>, <span class="at">dataset =</span> <span class="st">&quot;CA16&quot;</span>, <span class="at">type =</span> <span class="st">&quot;total&quot;</span>, <span class="at">query_type =</span> <span class="st">&quot;exact&quot;</span>)</span></code></pre></div>
<pre><code>## Warning: No exact matches found. Please check spelling and try again or consider using semantic or keyword search.
## See ?find_census_vectors() for more details.
## 
## Alternatively, you can launch the Censusmapper web API in a browser by calling explore_census_vectors(dataset)</code></pre>
<p>Unless otherwise specified, <code>find_census_vectors()</code> will
use exact search as the default option.</p>
</div>
<div id="keyword-search" class="section level3">
<h3>Keyword search</h3>
<p>Keyword search is meant to be used when you know the approximate
subject matter of the variable without knowing the exact variable you
are looking for. Under the hood, keyword search splits the query and
vector details into unique unigram tokens and then looks for the vectors
with the greatest number of matches.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&#39;commute mode&#39;</span>, <span class="at">dataset =</span> <span class="st">&#39;CA16&#39;</span>, <span class="at">type =</span> <span class="st">&#39;female&#39;</span>, <span class="at">query_type =</span> <span class="st">&#39;keyword&#39;</span>, <span class="at">interactive =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## # A tibble: 7 × 4
##   vector      type   label                                               details
##   &lt;chr&gt;       &lt;fct&gt;  &lt;chr&gt;                                               &lt;chr&gt;  
## 1 v_CA16_5794 Female Total - Main mode of commuting for the employed la… 25% Da…
## 2 v_CA16_5797 Female Car, truck, van - as a driver                       25% Da…
## 3 v_CA16_5800 Female Car, truck, van - as a passenger                    25% Da…
## 4 v_CA16_5803 Female Public transit                                      25% Da…
## 5 v_CA16_5806 Female Walked                                              25% Da…
## 6 v_CA16_5809 Female Bicycle                                             25% Da…
## 7 v_CA16_5812 Female Other method                                        25% Da…</code></pre>
<p>Keyword search will show all results that have the highest number of
unique keyword matches. What happens if there are other keyword matches
that have fewer total matches? By default, the function argument is set
as <code>interactive = TRUE</code>, which will prompt the user with a
console menu option to see the rest of the matches or not. If using
<code>find_census_vectors()</code> in a script or reproducible
documentation, we recommend setting this argument to
<code>interactive = FALSE</code>.</p>
</div>
<div id="semantic-search" class="section level3">
<h3>Semantic search</h3>
<p>Semantic search works best with phrases. Rather than the
decontextualized unigrams of keyword search, semantic search splits
queries and vector details into n-grams and finds matches using
approximate string distances based on the generalized Levenshtein
distance.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&quot;after tax incomes&quot;</span>, <span class="at">dataset =</span> <span class="st">&quot;CA16&quot;</span>, <span class="at">type =</span> <span class="st">&quot;total&quot;</span>, <span class="at">query_type =</span> <span class="st">&quot;semantic&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 56 × 4
##    vector      type  label                                               details
##    &lt;chr&gt;       &lt;fct&gt; &lt;chr&gt;                                               &lt;chr&gt;  
##  1 v_CA16_2210 Total Number of after-tax income recipients aged 15 year… Income…
##  2 v_CA16_2213 Total Median after-tax income in 2015 among recipients (… Income…
##  3 v_CA16_2306 Total Percentage with after-tax income                    Income…
##  4 v_CA16_2297 Total Total - After-tax income groups in 2015 for the po… Income…
##  5 v_CA16_2300 Total Without after-tax income                            Income…
##  6 v_CA16_2303 Total With after-tax income                               Income…
##  7 v_CA16_2309 Total Under $10,000 (including loss)                      Income…
##  8 v_CA16_2312 Total $10,000 to $19,999                                  Income…
##  9 v_CA16_2315 Total $20,000 to $29,999                                  Income…
## 10 v_CA16_2318 Total $30,000 to $39,999                                  Income…
## # … with 46 more rows</code></pre>
<p>Semantic search is more robust to spelling and punctuation issues
that may come up with exact search. For example, while this throws a
warning:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&quot;ojib cree&quot;</span>, <span class="at">dataset =</span> <span class="st">&quot;CA16&quot;</span>, <span class="at">type =</span> <span class="st">&quot;total&quot;</span>, <span class="at">query_type =</span> <span class="st">&quot;exact&quot;</span>)</span></code></pre></div>
<pre><code>## Warning: No exact matches found. Please check spelling and try again or consider using semantic or keyword search.
## See ?find_census_vectors() for more details.
## 
## Alternatively, you can launch the Censusmapper web API in a browser by calling explore_census_vectors(dataset)</code></pre>
<p>This will find the correct Census vector.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find_census_vectors</span>(<span class="st">&#39;ojib cree&#39;</span>, <span class="at">dataset =</span> <span class="st">&#39;CA16&#39;</span>, <span class="at">type =</span> <span class="st">&#39;total&#39;</span>, <span class="at">query_type =</span> <span class="st">&#39;semantic&#39;</span>)</span></code></pre></div>
<pre><code>## Multiple possible matches. Results ordered by closeness.</code></pre>
<pre><code>## # A tibble: 4 × 4
##   vector      type  label    details                                            
##   &lt;chr&gt;       &lt;fct&gt; &lt;chr&gt;    &lt;chr&gt;                                              
## 1 v_CA16_626  Total Oji-Cree Language; Total - Mother tongue for the total popu…
## 2 v_CA16_1433 Total Oji-Cree Language; Total - Language spoken most often at ho…
## 3 v_CA16_2676 Total Oji-Cree 25% Data; Total - Knowledge of languages for the p…
## 4 v_CA16_5930 Total Oji-Cree 25% Data; Work; Total - Language used most often a…</code></pre>
<p>Results are ordered by string proximity if there are multiple
possible matches.</p>
</div>
</div>
</div>
<div id="census-regions" class="section level1">
<h1>Census regions</h1>
<div id="standard-geographical-classification" class="section level2">
<h2>Standard Geographical Classification</h2>
<p>Statistics Canada uses an official classification of geographic areas
known as the <a href="https://www.statcan.gc.ca/en/subjects/standard/sgc/2021/introduction">Standard
Geographical Classification (SGC)</a>, which is updated periodically.
The latest version is based on the 2021 Census. Geographic
classification codes are standardized across Statistics Canada products,
including the Census as well as any other Statistics Canada dataset. In
practice, this means that the region ID for the Vancouver Census
subdivision is 5915022 across all products. In <code>cancensus</code>
the region ID code is used to identify the appropriate spatial vector
data to retrieve alongside Census data. These region IDs have a
predictable structure, where provinces are two digits, Census divisions
are 4 digits (including 2 for the province), and Census subdivisions
have 7 digits (including 2 for the province, and 2 for the Census
division).</p>
<pre><code>## # A tibble: 3 × 4
##      PR    CD   CSD name                         
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        
## 1    35    NA    NA Ontario                      
## 2    35    18    NA Durham (Regional municipality
## 3    35    18    13 Oshawa (City)</code></pre>
<p>These levels are hierarchical and complete in that a province is
split in Census divisions, which are then split into Census
subdivisions.</p>
<p>Geographies have standardized names for the province, Census
division, and Census subdivision levels, as well as Census metropolitan
areas and Census agglomerations. Lower geographic levels such as Census
tracts or dissemination areas (DA, EA, and DB) are not named or listed
but have unique identifying codes derived from their parent Census
subdivision.</p>
<pre><code>## # A tibble: 6 × 2
##   level     n
##   &lt;chr&gt; &lt;int&gt;
## 1 C         1
## 2 CA        9
## 3 CD      293
## 4 CMA      41
## 5 CSD    5161
## 6 PR       13</code></pre>
<p>There is also an additional region, with the id <code>01</code> and
the level code <code>C</code> which represents all of Canada as a
whole.</p>
<div id="a-note-on-census-metropolitan-areas-and-census-agglomerations" class="section level3">
<h3>A note on Census Metropolitan Areas and Census Agglomerations</h3>
<p>Data can also be extracted at the Census Metropolitan Area (CMA) or
Census Agglomeration (CA) level, which is derived from a variant of the
SGC known as the Statistical Area Classification. Hierarchically, CMAs
and CAs represent a collection of constituent Census subdivisions.</p>
<p>A Census metropolitan area consists of adjacent municipalities with a
defined core with a total population of at least 100,000 of which 50,000
or more must live in the core based on Census data. Adjacent
municipalities must have a high degree of integration with the core,
which Statistics Canada measures based on the commuting flows indicated
in Census data. Census Agglomeration areas have to have a core
population above 10,000.</p>
<p>All CMAs and CAs consist of Census subdivisions but not all Census
subdivisions are a subset of a CMA or a CA. For more details on CMAs and
CAs, consult Statistics Canada’s Census Dictionary article for <a href="https://www12.statcan.gc.ca/census-recensement/2021/ref/dict/az/Definition-eng.cfm?ID=geo009">Census
metropolitan areas (CMA) and census agglomerations (CA)</a>. All CMAs
and some CAs have data at the Census tract level, but most CAs do not.
The 2021 Census has 41 CMAs and 9 CAs with Census tracts that have their
own defined geography. There are a further 102 CAs without Census tracts
that do not have their own distinctly defined geographies.</p>
</div>
<div id="aside-dissemination-areas-blocks-and-enumeration-areas" class="section level3">
<h3>Aside: dissemination areas, blocks, and enumeration areas</h3>
<p><a href="https://www12.statcan.gc.ca/census-recensement/2021/ref/dict/az/Definition-eng.cfm?ID=geo021">Dissemination
areas</a> (DA) are the smallest atomic geographic unit at which all
census data is captured. DAs cover the entirety of Canada and follow the
boundaries of census subdivisions and census tracts. While inter-census
geographic stability is not guaranteed, they generally tend to be as
stable as the census tracts and census subdivisions that they make up.
In addition to census boundaries, DAs will generally follow natural
boundaries created by other spatial features like roads, railways, water
features, and designed to be spatially compact and with a target
population around 400-700 persons. The 2021 census data has 57,936
distinct DAs.</p>
<p><a href="https://www12.statcan.gc.ca/English/census01/products/reference/dict/geo024.htm">Enumeration
areas</a> (EA) were the DA equivalent for censuses prior to 2001.
Similar to DAs, EAs were used to as the basic level at which census data
was collected. They do not necessarily correspond accurately to DAs in
data from 2001 onwards.</p>
<p><a href="https://www12.statcan.gc.ca/census-recensement/2021/ref/dict/az/Definition-eng.cfm?ID=geo014">Dissemination
block</a> (DB) level data is available for the 2001-2021 datasets. DBs
are essentially city blocks, bounded by intersecting streets and
therefore are largely the product of road networks at the time of the
census. The geographies and identification codes of DBs are not
necessarily stable over time. DBs are split whenever they intersect with
boundaries of higher geographic levels in such a way as to ensure that
they can be aggregated upwards precisely. DBs only provide data for
population, dwelling counts, and number of households (from 2006
onwards) without any additional characteristic data. DBs with population
under 15 have their population counts adjusted for privacy. For the 2021
census, there are close to half a million DB distinct regions.</p>
</div>
</div>
<div id="viewing-available-census-regions" class="section level2">
<h2>Viewing available Census regions</h2>
<p>For any valid Census dataset, you can view all available Census
regions by calling <code>list_census_regions(dataset)</code>. This will
retrieve the <code>region</code> code, the <code>name</code>, and the
<code>level</code> code indicating the type of geography. Other
information includes population, municipal status, as well as parent
geographic ids for lower levels. All CMAs are included with their own
defined geography, as well as those CAs which have their own Census
tracts.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">list_census_regions</span>(<span class="st">&#39;CA21&#39;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 5,518 × 8
##    region name                      level      pop munic…¹ CMA_UID CD_UID PR_UID
##    &lt;chr&gt;  &lt;chr&gt;                     &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; 
##  1 01     Canada                    C     36991981 &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  2 35     Ontario                   PR    14223942 Ont.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  3 24     Quebec                    PR     8501833 Que.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  4 59     British Columbia          PR     5000879 B.C.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  5 48     Alberta                   PR     4262635 Alta.   &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  6 46     Manitoba                  PR     1342153 Man.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  7 47     Saskatchewan              PR     1132505 Sask.   &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  8 12     Nova Scotia               PR      969383 N.S.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
##  9 13     New Brunswick             PR      775610 N.B.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
## 10 10     Newfoundland and Labrador PR      510550 N.L.    &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;  
## # … with 5,508 more rows, and abbreviated variable name ¹​municipal_status</code></pre>
There are 53 CSD and 12 CD municipal status codes based on official
designations used by provinces, territories, and federal authorities.
These are often used to distinguish Census divisions and subdivisions
with similar or identical names. CAs with Census tracts and defined
geography have the code K, while those without have type code D.
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["geography"],"name":[1],"type":["chr"],"align":["left"]},{"label":["status_code"],"name":[2],"type":["chr"],"align":["left"]},{"label":["status"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"CD","2":"CDR","3":"Census division / Division de recensement"},{"1":"CD","2":"CT","3":"County / Comté"},{"1":"CD","2":"CTY","3":"County"},{"1":"CD","2":"DIS","3":"District"},{"1":"CD","2":"DM","3":"District municipality"},{"1":"CD","2":"MRC","3":"Municipalité régionale de comté"},{"1":"CD","2":"RD","3":"Regional district"},{"1":"CD","2":"REG","3":"Region"},{"1":"CD","2":"RM","3":"Regional municipality"},{"1":"CD","2":"TÉ","3":"Territoire équivalent"},{"1":"CD","2":"TER","3":"Territory / Territoire"},{"1":"CD","2":"UC","3":"United counties"},{"1":"CSD","2":"C","3":"City / Cité"},{"1":"CSD","2":"CC","3":"Chartered community"},{"1":"CSD","2":"CG","3":"Community government"},{"1":"CSD","2":"CN","3":"Crown colony / Colonie de la couronne"},{"1":"CSD","2":"COM","3":"Community"},{"1":"CSD","2":"CT","3":"Canton (municipalité de)"},{"1":"CSD","2":"CU","3":"Cantons unis (municipalité de)"},{"1":"CSD","2":"CV","3":"City / Ville"},{"1":"CSD","2":"CY","3":"City"},{"1":"CSD","2":"DM","3":"District municipality"},{"1":"CSD","2":"HAM","3":"Hamlet"},{"1":"CSD","2":"ID","3":"Improvement district"},{"1":"CSD","2":"IGD","3":"Indian government district"},{"1":"CSD","2":"IM","3":"Island municipality"},{"1":"CSD","2":"IRI","3":"Indian reserve / Réserve indienne"},{"1":"CSD","2":"LGD","3":"Local government district"},{"1":"CSD","2":"LOT","3":"Township and royalty"},{"1":"CSD","2":"M","3":"Municipality / Municipalité"},{"1":"CSD","2":"MD","3":"Municipal district"},{"1":"CSD","2":"MÉ","3":"Municipalité"},{"1":"CSD","2":"MU","3":"Municipality"},{"1":"CSD","2":"NH","3":"Northern hamlet"},{"1":"CSD","2":"NL","3":"Nisga'a land"},{"1":"CSD","2":"NO","3":"Unorganized / Non organisé"},{"1":"CSD","2":"NV","3":"Northern village"},{"1":"CSD","2":"P","3":"Parish / Paroisse (municipalité de)"},{"1":"CSD","2":"PE","3":"Paroisse (municipalité de)"},{"1":"CSD","2":"RCR","3":"Rural community / Communauté rurale"},{"1":"CSD","2":"RDA","3":"Regional district electoral area"},{"1":"CSD","2":"RGM","3":"Regional municipality"},{"1":"CSD","2":"RM","3":"Rural municipality"},{"1":"CSD","2":"RV","3":"Resort village"},{"1":"CSD","2":"S-É","3":"Indian settlement / Établissement indien"},{"1":"CSD","2":"SA","3":"Special area"},{"1":"CSD","2":"SC","3":"Subdivision of county municipality / Subdivision municipalité de comté"},{"1":"CSD","2":"SÉ","3":"Settlement / Établissement"},{"1":"CSD","2":"SET","3":"Settlement"},{"1":"CSD","2":"SG","3":"Self-government / Autonomie gouvernementale"},{"1":"CSD","2":"SM","3":"Specialized municipality"},{"1":"CSD","2":"SNO","3":"Subdivision of unorganized / Subdivision non organisée"},{"1":"CSD","2":"SV","3":"Summer village"},{"1":"CSD","2":"T","3":"Town"},{"1":"CSD","2":"TC","3":"Terres réservées aux Cris"},{"1":"CSD","2":"TI","3":"Terre inuite"},{"1":"CSD","2":"TK","3":"Terres réservées aux Naskapis"},{"1":"CSD","2":"TL","3":"Teslin land"},{"1":"CSD","2":"TP","3":"Township"},{"1":"CSD","2":"TV","3":"Town / Ville"},{"1":"CSD","2":"V","3":"Ville"},{"1":"CSD","2":"VC","3":"Village cri"},{"1":"CSD","2":"VK","3":"Village naskapi"},{"1":"CSD","2":"VL","3":"Village"},{"1":"CSD","2":"VN","3":"Village nordique"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="searching-through-named-census-regions" class="section level2">
<h2>Searching through named Census regions</h2>
<p>We can also search through all named geographies. This will return
any geographies that have a name that matches or partially matches the
search query.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">search_census_regions</span>(<span class="st">&quot;Vancouver&quot;</span>,<span class="st">&quot;CA21&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 7 × 8
##   region  name              level     pop municipal_status CMA_UID CD_UID PR_UID
##   &lt;chr&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; 
## 1 59933   Vancouver         CMA   2642825 B                &lt;NA&gt;    &lt;NA&gt;   59    
## 2 5915    Greater Vancouver CD    2642825 RD               &lt;NA&gt;    &lt;NA&gt;   59    
## 3 5915022 Vancouver         CSD    662248 CY               59933   5915   59    
## 4 5915046 North Vancouver   CSD     88168 DM               59933   5915   59    
## 5 5915051 North Vancouver   CSD     58120 CY               59933   5915   59    
## 6 5915055 West Vancouver    CSD     44122 DM               59933   5915   59    
## 7 5915020 Metro Vancouver A CSD     18612 RDA              59933   5915   59</code></pre>
</div>
</div>
<div id="exploring-census-variable-vectors-and-regions-interactively" class="section level1">
<h1>Exploring Census variable vectors and regions interactively</h1>
<p>Sometimes it can be easier to find the right vectors or regions by
exploring the layout and hierarchy of Census data. This is especially
true when we are not sure of what information is available or are not
sure where to start. Finding the right Census geographic code on a map
will be easier for some than using named search. This is also handy if
we want to assemble a custom aggregation of region codes at different
hierarchies.</p>
<p>To facilitate this, we have included a couple of convenience
functions that take you directly to an interactive tool with variable
and region details on the <a href="https://censusmapper.ca/api">Censusmapper website</a>. To explore
the hierarchical variable structure of a given dataset, say the 2006
Census, running <code>explore_census_vectors(dataset = &quot;CA06&quot;)</code>.
To view Census geography on an interactive map, there is
<code>explore_census_regions(dataset = &quot;CA16&quot;)</code>. As usual, vectors
and geographies for different Census datasets can be retrieved by using
the appropriate dataset code for the <code>dataset</code> argument.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
